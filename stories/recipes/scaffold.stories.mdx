import { Meta } from '@storybook/addon-docs';
import Code from '../assets/code.svg';
import AdvanceLevel from '../assets/thermometer_full.svg';
import ScaffoldStep1 from '../assets/scaffold-step1.png';
import ScaffoldStep2 from '../assets/scaffold-step2.png';
import ScaffoldStep21 from '../assets/scaffold-step2-1.png';
import ScaffoldStep3 from '../assets/scaffold-step3.png';
import ScaffoldStep31 from '../assets/scaffold-step3-1.png';
import ScaffoldStep4 from '../assets/ScaffoldStep4.png';
import ScaffoldStepFinal from '../assets/scaffold-final.gif';

import '../styles.css'


<Meta title="Welcome/Recipes/Scaffold a SPA" />

<div className="recipe">
  <img src={Code} alt="Code" height="160" />
  <div classNamw="flex-col">
    <h1 className="heading">Scaffold a SPA Services</h1>
    <small className="flex"> <img src={AdvanceLevel} alt="Intermedite Level" height="20" /> Advance level</small>
    <p>In this Recipe, we will create a full SPA with web components.
      We will have all the fixings for a great meal. Routing, localization, bundling,
      linting, unit testing, environment variables, file structure, architecture
      and what ever else we can fit.
    </p>
  </div>
</div>



### Prequisite

While no expert knowledge is needed there are numerous steps to scaffolding a
site from the ground up.  Before each topic feel free to research a bit more about
a tool or process we will be using.

It is expected that you already have a perference of `IDE(a.k.a Code editor)` and
knowledge of using a `console` and/or `shell terminal`, `Git`, `Node.js` and `NPM` which is required to continue.


### Expected Results

What we hope to appcomplish is a full front-end workspace for developers
to add code, lint, test and bundle everything so it can be deployed. We should be
able to bundle the application so it can be served and hosted on the web.

>This starter can be used for projects of all sizes.

> The results of this tutorial can be found here:

## Inital Files

We need a set of inital files.  When creating your new repo there is likey a `README.md` file.
This will be important to update at the end.  If your project does not have one make sure to create one.

Before We create each file lets understand why it is needed.


| File | Reason |
|:---------|:---------|
| README.md | Vital documentation as to what the project is about and how to use it. |
| .editorconfig | Helps your IDE(a.k.a Code editor) know how to format the code |
| .gitignore | Required to inform Git what files to ingnore and not be checked in |
| package.json | Required to install dependencies, provide project information and execution scripts |
| src/main.js | Our starting application JavaScript file |
| src/index.html | Our Base application HTML file |
| webpack.config.js | The config for bundling the application |


Create a **.editorconfig** file and add the following:

```
# Editor configuration, see http://editorconfig.org
root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.md]
max_line_length = off
trim_trailing_whitespace = false
```

This is a good starting **.gitignore** file.  Feel free to add any other folders/files
needed.
```
# IDE
._*
.cache
.DS_Store
.env
.envrc
.idea
.npmrc
.project
.settings
.scannerwork
.tmproj
*.esproj
*.sublime-project
*.sublime-workspace
nbproject/
Thumbs.db
.vscode/*
.vs/*
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# extensions
*.diff
*.err
*.log
*.orig
*.rej
*.swo
*.swp
*.tgz
*.vi
*.zip
*~

# Folders
node_modules/
coverage/
dist/*
```

We can start with a basic **package.json** file and add our dependencies as we build our
scaffold.

```json
{
  "name": "my_app",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "build": "./node_modules/.bin/webpack --mode production --config webpack.config.js",
    "build:beta": "./node_modules/.bin/webpack --mode development --config webpack.config.js",
    "start": "./node_modules/.bin/webpack serve --mode development --config webpack.config.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
}
```

From the root of the project create a folder called `src/` and within that folder a file called `main.js`.

```js
function component() {
  const element = document.createElement('div')

  element.innerHTML = `<h1>Hello Mettle</h1>`

  return element
}

document.body.appendChild(component())
```

Within the same `src/` folder create an **index.html** file.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Getting Started</title>
  </head>
  <body>
    <noscript>
      <!-- No JS alternative -->
    </noscript>
  </body>
</html>
```

For the last initial file lets create **webpack.config.js**.

> Note this configuration is for **Webpack 5**

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { resolve } = require('path')

module.exports = (env, argv) => {
  const IS_BUILD = env.WEBPACK_BUILD
  return {
    devServer: {
      historyApiFallback: {
        rewrites: [
          { from: /.*\.html?/, to: '/' },
          { from: /^[\w/]+$/, to: '/' },
        ],
        verbose: true
      },
      host: '0.0.0.0',
      open: true,
      port: 2022,
    },
    entry: './src/main.js',
    module: {
      rules: [
        {
          test: /\.(png|svg|jpg|jpeg|gif)$/i,
          type: 'asset/resource',
        },
        {
          test: /\.html$/i,
          exclude: /index\.html$/i,
          type: 'asset/source',
        },
      ],
    },
    output: {
      assetModuleFilename: 'assets/[name][ext]',
      clean: true,
      filename: 'main.js',
      path: resolve(__dirname, 'dist'),
    },
    plugins: [
      new HtmlWebpackPlugin({
        base: IS_BUILD ? false : '/',
        inject: 'body',
        template: './src/index.html',
        scriptLoading: 'module'
      }),
    ],
  }
}
```

Before we can test we will need to install some dependencies.  Make sure all files above
are created and saved.

Install these from the command line like so:

> Note the indicator for the shell command **$** is removed for easy copy and paste

**devDependencies**
```sh
npm install html-webpack-plugin webpack webpack-cli webpack-dev-server --save-dev
```

**dependencies**
```sh
npm install @johnsonandjohnson/mettle-components --save
```

### Final Results for Inital Files setup

Once this is all configured we will be able to start our application.  Run the following
command.  This was configured in the `package.json` file scripts section.

> All scripts should be excuted where the `package.json` file is located.

```sh
$ npm start
```

You should see the application open from your default web browser and display something
that looks like this.
<img src={ScaffoldStep1} class="img-border" height="200" />


The current file structure should look something like this
```
.
├── node_modules
├── src
│   ├── index.html
│   └── main.js
├── .editorconfig
├── .gitignore
├── package-lock.json
├── package.json
├── README.md
└── webpack.config.js
```

## Before starting the next step

In the terminal enter `ctrl + c` to end the process. The webpack development server
will shut down.

## CSS structure and bundle

Right after HTML, CSS is nesscary for the web experince. Importing CSS files are ideal
but not yet nativly supported(but getting there).  What we will setup is CSS bundling
with webpack so it will include imported CSS files into the final HTML page.  This will
allow us to seperate our CSS files if needed as it makes sense.

Create the folder and file structure like so **src/css/index.css** and include the following:

```css
@import './variables.css';
@import './structure.css';
@import './custom.css';
@import './effects.css';
```

About these files

| File | Purpose |
|:---------|:---------|
| variables.css | Using CSS variables will help organize your CSS resuable properties |
| structure.css | While many will use a CSS framework, reusable classes for structuring your application can be placed here |
| custom.css | Most projects have custom CSS regardless of what CSS framework you use. They can be placed here |
| effects.css | Using motion is not highly recommended, but there might be some transitions or animations that make sense. |

You guessed it also add the following files to **src/css/**

> Please Note that we recommend using `em` and `rem`.

**variables.css**
```css
:root {
  --background: #f5f5f5;
  --on-background: #3c3a36;
  --surface: #e8e7e3;
  --on-surface: #999;

  --header: #fcfcfc;
  --on-header: #494949;
  --nav: #fff;
  --on-nav: #000;

  --primary: #3d5a80;
  --on-primary: #fff;
  --primary-variant: #98c1d9;
  --secondary: #ee6c4d;
  --on-secondary: #fff;

  --danger: #ff0011;
  --info: #4fd2fa;
  --success: #75dd0c;
  --warning: #f7f313;

  --base-size: 1rem;
  --base-size-xs: calc(var(--base-size) / 2);
  --base-size-md: calc(var(--base-size) * 2);
  --base-size-lg: calc(var(--base-size) * 4);
  --base-border-radius: 0.25rem;
}
```

**structure.css**
```css
html,
body {
  background-color: var(--background, #ddd);
  font-family: sans-serif;
  font-size: 0.94em;
  margin: 0;
  padding: 0;
}

/* Flex Grid */

.row,
.column {
  box-sizing: border-box;
  display: flex;
  flex: 0 1 auto;
  flex-flow: row wrap;
  word-break: break-all;
}

.column {
  flex-direction: column;
}

.flex-no-flow {
  flex-flow: initial;
}

.flex-stretch {
  align-items: stretch;
  flex: 1;
}

.flex-end {
  justify-content: flex-end;
}

.self-center {
  align-self: center;
  justify-self: center;
}

.col,
.col-1,
.col-2,
.col-4,
.col-6,
.col-8,
.col-10,
.col-12 {
  box-sizing: border-box;
  flex: 0 0 auto;
}

.col {
  flex-grow: 1;
  flex-basis: 0;
  max-width: 100%;
}

.col-1 {
  flex-basis: calc(100% * (1 / 12));
}

.col-2 {
  flex-basis: calc(100% * (2 / 12));
}

.col-3 {
  flex-basis: calc(100% * (3/12));
}

.col-4 {
  flex-basis: calc(100% * (4 / 12));
}

.col-6 {
  flex-basis: calc(100% * (6 / 12));
}

.col-8 {
  flex-basis: calc(100% * (8 / 12));
}

.col-10 {
  flex-basis: calc(100% * (10 / 12));
}

.col-12 {
  flex-basis: calc(100% * (12 / 12));
}

.gap-xs {
  gap: var(--base-size-xs);
}

.gap-sm {
  gap: var(--base-size);
}

.gap-md {
  gap: var(--base-size-md);
}

.gap-lg {
  gap: var(--base-size-lg);
}

/* Special Cases */

[hidden] {
  display: none !important;
}
```

**custom.css**
```css
/* Buttons */

.primary-button,
.secondary-button {
  background-color: var(--primary);
  border: none;
  border-radius: .313rem;
  color: var(--on-primary);
  cursor: pointer;
  font-size: 0.8rem;
  outline: none;
  padding: 0.6rem 1rem;
}

.secondary-button {
  background-color: var(--secondary);
  color: var(--on-secondary);
}
```

**effects.css**
```css
@media (prefers-reduced-motion: no-preference) {
  /* Button push effect */
  .push-button {
    transition: transform 0.1s ease-in-out;
  }

  .push-button:active {
    transform: scale(0.98);
  }
}
```

Add the following line to the **src/main.js** file. All imports should be placed at
the top of the file.

```js
import './css/index.css'
```


Next we need to add dev dependencies and update webpack to identify the CSS import, bundle it and
include it with the generated index.html page.

**devDependencies**
```sh
npm install css-loader mini-css-extract-plugin --save-dev
```


Replace the **webpack.config.js** file with the following.

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const { resolve } = require('path')

module.exports = (env, argv) => {
  const IS_BUILD = env.WEBPACK_BUILD
  return {
    devServer: {
      historyApiFallback: {
        rewrites: [
          { from: /.*\.html?/, to: '/' },
          { from: /^[\w/]+$/, to: '/' },
        ],
        verbose: true
      },
      host: '0.0.0.0',
      open: true,
      port: 2022,
    },
    entry: './src/main.js',
    module: {
      rules: [
        {
          test: /\.css$/i,
          use: [MiniCssExtractPlugin.loader, 'css-loader'],
        },
        {
          test: /\.(png|svg|jpg|jpeg|gif)$/i,
          type: 'asset/resource',
        },
        {
          test: /\.html$/i,
          exclude: /index\.html$/i,
          type: 'asset/source',
        },
      ],
    },
    output: {
      assetModuleFilename: 'assets/[name][ext]',
      clean: true,
      filename: 'main.js',
      path: resolve(__dirname, 'dist'),
    },
    plugins: [
      new MiniCssExtractPlugin(),
      new HtmlWebpackPlugin({
        base: IS_BUILD ? false : '/',
        inject: 'body',
        template: './src/index.html',
        scriptLoading: 'module'
      }),
    ],
  }
}
```

Now that everything is added and configured we can run the development server.

```sh
$ npm start
```

The page should now look like this.

<img src={ScaffoldStep2} class="img-border" height="200" />

To see our development changes with hot reloading go into the **custom.css** file
and add the following.

```css
h1 {
  color: red;
}
```

The change will be applied and reloaded into the site. Feel free to remove the css
after seeing the change.

<img src={ScaffoldStep21} class="img-border" height="200" />

The file structure should now look like this.

```
.
├── node_modules
├── src
│   ├── css
│   │    ├── custom.css
│   │    ├── effects.css
│   │    ├── index.css
│   │    ├── structure.css
│   │    └── variables.css
│   ├── index.html
│   └── main.js
├── .editorconfig
├── .gitignore
├── package-lock.json
├── package.json
├── README.md
└── webpack.config.js
```


## Adding Components

Component based development will be esscential to the development of the web app.

Under `src` lets add a `components` folder.

We need to create an `index.js` file and a `core-header.js` file.
We will include any components within this folder.  It is recommended many to all
parts of your app are built using web components for reusablility and encapuslation.

In doing this, your HTML can act more like a place holder while your components will
render the solution needed for that section or page.

Before we create the component, lets create the HTML template for the component.
This will be useful for component HTML that might be to large to inculde directly
into the component.

> Note that this is supported only by using webpack

Add the `src/components/core-header.html`

```html
<h1><slot></slot></h1>
```


Add the  `src/components/core-header.js` file

```js
import CORE_HEADER_HTML from './core-header.html'

const TAG_NAME = 'core-header'
const BASE = window.HTMLElement

if (!window.customElements.get(TAG_NAME)) {
  window.customElements.define(TAG_NAME, class extends BASE {
    constructor() {
      super('')
      this.attachShadow({ mode: 'open' })
      .appendChild(this._generateTemplate().content.cloneNode(true))
    }

    _generateTemplate() {
      const template = document.createElement('template')
      template.innerHTML = CORE_HEADER_HTML
      return template
    }

  })
}
```

Create and add the `src/components/index.js`

```js
import './core-header.js'
```


We will need to update Webpack to ensure we can resolve the location for our components.
We will also include the other folders that will be configured.

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const { resolve } = require('path')

module.exports = (env, argv) => {
  const IS_BUILD = env.WEBPACK_BUILD
  return {
    devServer: {
      historyApiFallback: {
        rewrites: [
          { from: /.*\.html?/, to: '/' },
          { from: /^[\w/]+$/, to: '/' },
        ],
        verbose: true
      },
      host: '0.0.0.0',
      open: true,
      port: 2022,
    },
    entry: './src/main.js',
    module: {
      rules: [
        {
          test: /\.css$/i,
          use: [MiniCssExtractPlugin.loader, 'css-loader'],
        },
        {
          test: /\.(png|svg|jpg|jpeg|gif)$/i,
          type: 'asset/resource',
        },
        {
          test: /\.html$/i,
          exclude: /index\.html$/i,
          type: 'asset/source',
        },
      ],
    },
    output: {
      assetModuleFilename: 'assets/[name][ext]',
      clean: true,
      filename: 'main.js',
      path: resolve(__dirname, 'dist'),
    },
    plugins: [
      new MiniCssExtractPlugin(),
      new HtmlWebpackPlugin({
        base: IS_BUILD ? false : '/',
        inject: 'body',
        template: './src/index.html',
        scriptLoading: 'module'
      }),
    ],
    resolve: {
      alias: {
        components: resolve(__dirname, 'src/components'),
        features: resolve(__dirname, 'src/features'),
        services: resolve(__dirname, 'src/services'),
      },
      extensions: ['.js']
    },
  }
}
```

**Alias Imports**

Using the webpack resolve will make it easier to not have to worry about import directories.

The main folders that will be included next will be all the files needed for a
single page application(SPA).


| Folder | Purpose |
|:---------|:---------|
| components | All custom web components will be placed here to organize the site into widgets. |
| features | All routes and controllers will be placed for each feature page here. |
| services | All providers, API fetches and bussniess logic will be placed here.  Components and features will directly access these services. |

Now we can update the `main.js` file like so

```js
import './css/index.css'
import 'components'

function component() {
  const element = document.createElement('core-header')

  element.innerHTML = 'Hello Mettle'

  return element
}

document.body.appendChild(component())
```


The file structure should now look like this.

```
.
├── node_modules
├── src
│   ├── components
│   │    ├── core-header.html
│   │    ├── core-header.js
│   │    └── index.js
│   ├── css
│   │    ├── custom.css
│   │    ├── effects.css
│   │    ├── index.css
│   │    ├── structure.css
│   │    └── variables.css
│   ├── index.html
│   └── main.js
├── .editorconfig
├── .gitignore
├── package-lock.json
├── package.json
├── README.md
└── webpack.config.js
```


## Importing 3rd party Components

We will utilize Mettle components and a
vanilla web component from <a href="https://github.com/vanillawc">vanillawc</a>


Having already installed Mettle Components, we can add it to the `main.js` file.

```js
import './css/index.css'
import '@johnsonandjohnson/mettle-components'
import 'components'

function component() {
  const element = document.createElement('core-header')

  element.innerHTML = 'Hello Mettle'

  return element
}

document.body.appendChild(component())
```

To test that the import works update the `index.html` file to test the `mettle-tool-tip`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Getting Started</title>
  </head>
  <body>
    <span id="id-9cff94d5-b2d8-48ef-a615-bad86bb9924f">Hover or tap me for tip</span>
    <mettle-tool-tip
      data-position="bottom"
      data-for="id-9cff94d5-b2d8-48ef-a615-bad86bb9924f"><p>Tool Tip Works!</p></mettle-tool-tip>
    <noscript>
      <!-- No JS alternative -->
    </noscript>
  </body>
</html>
```

The site should now have the tool-tip.

<img src={ScaffoldStep3} class="img-border" height="200" />

**Importing another component**

From the root directory where the `package.json` file is located run the following commands

```sh
npm install --save @vanillawc/wc-datepicker
```

Update the `main.js` to inculde the datepicker.

```js
import './css/index.css'
import '@johnsonandjohnson/mettle-components'
import '@vanillawc/wc-datepicker'
import 'components'

function component() {
  const element = document.createElement('core-header')

  element.innerHTML = 'Hello Mettle'

  return element
}

function dateComponent() {
  const picker = document.createElement('wc-datepicker')
  const  input = document.createElement('input')
  input.setAttribute('type', 'text')
  picker.appendChild(input)
  return picker
}

document.body.appendChild(component())
document.body.appendChild(dateComponent())
```

The site should now have a datepicker.

<img src={ScaffoldStep31} class="img-border" height="300" />

> There are many more options for production ready web components.  Feel free to use and mix all that
makes sense for your project.

## Services

While we are not doing a deep dive into building services (a.k.a Providers)
we will inculde some already
built services from Mettle along with a structure that will allow you to add your own
custom services.

Under `src` lets add a `services` folder.

create the following file `src/services/index.js`

```js
import {
  Debounce,
  HtmlMarker,
  HttpFetch,
  I18n,
  Observable,
  ReadyState,
  Roles,
  Router
} from '@johnsonandjohnson/mettle-components/services'

import { Constants } from './constants.js'

export {
  Constants,
  Debounce,
  HtmlMarker,
  HttpFetch,
  I18n,
  Observable,
  ReadyState,
  Roles,
  Router,
}
```

create the following file `src/services/constants.js`

```js
export const Constants = {
  ROUTES: {
    ABOUT: '/about',
    HOME: '/home',
  },
}
```


Services are imported on an as needed basis.  The file structure should now look like this.

```
.
├── node_modules
├── src
│   ├── components
│   │    ├── core-header.html
│   │    ├── core-header.js
│   │    └── index.js
│   ├── css
│   │    ├── custom.css
│   │    ├── effects.css
│   │    ├── index.css
│   │    ├── structure.css
│   │    └── variables.css
│   ├── services
│   │    ├── constants.js
│   │    └── index.js
│   ├── index.html
│   └── main.js
├── .editorconfig
├── .gitignore
├── package-lock.json
├── package.json
├── README.md
└── webpack.config.js
```


## Features

Feature pages will be our controllers for routing. We will handle
any logic before and after a route along with what to display to the user.

Under `src` lets add a `features/dashboard` folder.

Create a `src/features/dashboard/home.js` file.

```js
import {
  Constants,
  Router
} from 'services'

import HTML from './home.html'

const HomeCtrlLoader = async (req, next) => {
  const $routeDisplay = document.querySelector('.route-display')
  await $routeDisplay.insertContent(HTML)
  next()
}

const HomeCtrl = async (req, next) => {

  //After content is loaded any other logic

  next()
}

Router
  .setPath(Constants.ROUTES.HOME, HomeCtrlLoader, HomeCtrl)

```

create a `src/features/dashboard/home.html` file.

```html
<template>
  <h1>Home Page</h1>
</template>
```

We will need to make sure this feature page is available in the application.

create a `src/features/index.js` file.

```js
import './dashboard/home.js'
```

We will update the `main.js` file

```js
import './css/index.css'
import '@johnsonandjohnson/mettle-components'
import '@vanillawc/wc-datepicker'
import 'components'
import 'features'

import {
  Constants,
  Router,
} from  'services'

Router.defaultPath(Constants.ROUTES.HOME)


const $links = Array.from(document.querySelectorAll('a[rel*="/"]'))
$links.map(a => {
  a.addEventListener('click', evt => {
    evt.preventDefault()
    removeActiveClass()
    a.classList.add('active')
    Router.goto(a.getAttribute('rel'), a.getAttribute('title'))
  })
})

function removeActiveClass() {
  $links.forEach(link => {
    link.classList.remove('active')
  })
}
```

Last thing to to update the index.html page with the links and router display.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Getting Started</title>
  </head>
  <body>
    <nav>
      <a href="#" rel="home/" title="Main Page" class="active">Home</a>
      <a href="#" rel="about/" title="About Page">About</a>
    </nav>
    <mettle-transition-display class="route-display"></mettle-transition-display>
    <noscript>
      <!-- No JS alternative -->
    </noscript>
  </body>
</html>
```

The result with the about page will look something like this.

<img src={ScaffoldStepFinal} class="img-border" height="200" />


The file structure should now look like this.

```
.
├── node_modules
├── src
│   ├── components
│   │    ├── core-header.html
│   │    ├── core-header.js
│   │    └── index.js
│   ├── css
│   │    ├── custom.css
│   │    ├── effects.css
│   │    ├── index.css
│   │    ├── structure.css
│   │    └── variables.css
│   ├── features
│   │    ├── dashboard
│   │    │    ├── about.html
│   │    │    ├── about.js
│   │    │    ├── home.html
│   │    │    └── home.js
│   │    └── index.js
│   ├── services
│   │    ├── constants.js
│   │    └── index.js
│   ├── index.html
│   └── main.js
├── .editorconfig
├── .gitignore
├── package-lock.json
├── package.json
├── README.md
└── webpack.config.js
```


## Environment Variables

> **It is important to note that you should never put any sensitive data
in your application that can be viewed publicly.**

Environment variables are vital to a web application. Reasons to use
them:
- Secret values
- Configurable values

Values like the application port or rest API urls can be added here.
This is great to make sure each server or environment is setup as needed e.g.
(dev, qa, beta, prod).

> Note that the `.env` file should never be checked in by
anyone and should be created and maintained only in the server that is hosting the
application.

We will be using `dotenv-extended` to import the variables from a `.env` file
into webpack. Let's get it installed.

**devDependencies**
```sh
npm install dotenv-extended --save-dev
```

Once installed we need to create the `.env.defaults` file.  While each developer
is responsible for creating their own `.env` file(following the README.md file),
the defaults can at least guide the developer with the expected values.

create a `.env.defaults` file.

```sh
UI_APP_PORT=2022
UI_API_HOST=
```

We can update the `webpack.config.js` file to inject these environment variables
into the application. Note that this preference is in favor of treating environment
variables like an import vs a global variable.  We will also filter out variables
we do not want to expose to the UI.

create a `environment.build.js` file
```js
const { resolve } = require('path')
require('dotenv-extended').load({
  errorOnMissing: true,
  path: resolve(__dirname, '.env')
})
const UI_ENV_VARS = Object.entries(process.env)
  .filter(([key]) => key.startsWith('UI_'))
  .reduce((acc, [key, val]) =>
    ({...acc, [key]:val})
  ,{})
module.exports = UI_ENV_VARS
```

replace `webpack.config.js`
```js
const UI_ENV_VARS = require('./environment.build')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const { resolve } = require('path')

module.exports = (env, argv) => {
  const IS_BUILD = env.WEBPACK_BUILD
  return {
    devServer: {
      historyApiFallback: {
        rewrites: [
          { from: /.*\.html?/, to: '/' },
          { from: /^[\w/]+$/, to: '/' },
        ],
        verbose: true
      },
      host: '0.0.0.0',
      open: true,
      port: UI_ENV_VARS.UI_APP_PORT,
    },
    entry: './src/main.js',
    externals: {
        Environment: JSON.stringify(UI_ENV_VARS)
    },
    module: {
      rules: [
        {
          test: /\.css$/i,
          use: [MiniCssExtractPlugin.loader, 'css-loader'],
        },
        {
          test: /\.(png|svg|jpg|jpeg|gif)$/i,
          type: 'asset/resource',
        },
        {
          test: /\.html$/i,
          exclude: /index\.html$/i,
          type: 'asset/source',
        },
      ],
    },
    output: {
      assetModuleFilename: 'assets/[name][ext]',
      clean: true,
      filename: 'main.js',
      path: resolve(__dirname, 'dist'),
    },
    plugins: [
      new MiniCssExtractPlugin(),
      new HtmlWebpackPlugin({
        base: IS_BUILD ? false : '/',
        inject: 'body',
        template: './src/index.html',
        scriptLoading: 'module'
      }),
    ],
    resolve: {
      alias: {
        components: resolve(__dirname, 'src/components'),
        features: resolve(__dirname, 'src/features'),
        services: resolve(__dirname, 'src/services'),
      },
      extensions: ['.js']
    },
  }
}
```

in your application, to access these variables you can import them to the file like so:

```js
import { UI_API_HOST } from 'Environment'
```


The file structure should now look like this.

```
.
├── node_modules
├── src
│   ├── components
│   │    ├── core-header.html
│   │    ├── core-header.js
│   │    └── index.js
│   ├── css
│   │    ├── custom.css
│   │    ├── effects.css
│   │    ├── index.css
│   │    ├── structure.css
│   │    └── variables.css
│   ├── features
│   │    ├── dashboard
│   │    │    ├── about.html
│   │    │    ├── about.js
│   │    │    ├── home.html
│   │    │    └── home.js
│   ├── services
│   │    ├── constants.js
│   │    └── index.js
│   ├── index.html
│   └── main.js
├── .editorconfig
├── .env.defaults
├── .gitignore
├── environment.build.js
├── package-lock.json
├── package.json
├── README.md
└── webpack.config.js
```

## Files and Assets

More often than not, files such as JSON, images etc. will need a way to be included
in the application.  Webpack has a setup to include these files.

Create a folder called `assets`.  Feel free to include anything need for the application
but know that webpack will copy all contents of this folder and to the application build.




The file structure should now look like this.

```
.
├── assets
│   ├── locales
│   │    └── en.json
│   ├── compass.png
│   ├── hamburger.png
├── node_modules
├── src
│   ├── components
│   │    ├── core-header.html
│   │    ├── core-header.js
│   │    └── index.js
│   ├── css
│   │    ├── custom.css
│   │    ├── effects.css
│   │    ├── index.css
│   │    ├── structure.css
│   │    └── variables.css
│   ├── features
│   │    ├── dashboard
│   │    │    ├── about.html
│   │    │    ├── about.js
│   │    │    ├── home.html
│   │    │    └── home.js
│   ├── services
│   │    ├── constants.js
│   │    └── index.js
│   ├── index.html
│   └── main.js
├── .editorconfig
├── .env.defaults
├── .gitignore
├── environment.build.js
├── package-lock.json
├── package.json
├── README.md
└── webpack.config.js
```

## Conclusion

This tutorial is just a first step to using web components in a way that can be
utilized for building web applications.  There are a few more things to consider

- Unit testing
- Linting
- Running the application
- Other plugin considerations with webpack
- PWA

The final template will also include the about page along with a scaffold of all
the things mentioned above.

Now that you have a basics down to build your application, next we need to discuss
essentially how to architect a front-end application with proven patterns.

